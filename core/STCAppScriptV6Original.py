"""
STC_APP_Scriptv6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nz_MGqPs5z1rz_G6NBl8xH-dQJxeK1Z3 : Private
    Author : Hamza Qureshi

DESCRIPTION
This code include following :
1. Create demo data dynamic method
2. Generate all parameters added by user from Application/settings.json[Working Fine]
3. Get input file
4. Create output CSV or Text files [data, laser and server files] as well
"""

# !pip install pycryptodome
# you can use requirements.txt
from core.GlobalParams import PARAMETERS, DATA_FRAMES

# from GlobalParams import PARAMETERS, DATA_FRAMES
# from custom_json import JsonHandler
from typing import Optional, List, Dict, Any, Tuple
from Crypto.Cipher import AES
from io import BytesIO
import secrets
import pandas as pd
import collections
import binascii
import datetime
import random
import string
import uuid
import json
import time
import os

CONFIGURATION_FILE_PATH = "settings.json"

# default_headers = [
#     "ICCID",
#     "IMSI",
#     "PIN1",
#     "PUK1",
#     "PIN2",
#     "PUK2",
#     "KI",
#     "EKI",
#     "OPC",
#     "ADM1",
#     "ADM6",
#     "ACC",
# ]

default_headers = (
    "ICCID",
    "IMSI",
    "PIN1",
    "PUK1",
    "PIN2",
    "PUK2",
    "KI",
    "EKI",
    "OPC",
    "ADM1",
    "ADM6",
    "ACC",
    "KIC1",
    "KID1",
    "KIK1",
    "KIC2",
    "KID2",
    "KIK2",
    "KIC3",
    "KID3",
    "KIK3"
)

"""FUNCTION DEFINITIONS"""
# Using 16bit zeroes as IV for the AES algo

IV = binascii.unhexlify("00000000000000000000000000000000")


def aes_128_cbc_encrypt(key, text):
    """AES encryption function

    Args:
        key (str): secret key
        text (str): text to encrypt

    Returns:
        str: encrypted text
    """
    keyb = binascii.unhexlify(key)
    textb = binascii.unhexlify(text)

    # ===========================#
    # ==========E[KI]K4==========#
    # ===========================#

    encryptor = AES.new(keyb, AES.MODE_CBC, IV=IV)
    ciphertext = encryptor.encrypt(textb)
    return ciphertext.hex().upper()


def gen_ki():
    """Generate random key based on uuid4 standard Universally Unique Identifier (UUID)
    Returns:
        str: random key of 128 bit in hex form
    """

    """Changed to secrets reason test report for uuid is not good as compared to secrets """
    return str(secrets.token_hex(16)).upper()


def gen_otas():
    """Generate random key based on uuid4 standard Universally Unique Identifier (UUID)
    Returns:
        str: random key of 128 bit in hex form
    """

    """Changed to secrets reason test report for uuid is not good as compared to secrets """
    return str(secrets.token_hex(16)).upper()


def gen_k4():
    """Generate Transport key

    Returns:
        str: Transport key of size 256 bit
    """
    return str(secrets.token_hex(32)).upper()


def gen_opc(op, ki):
    return calc_opc_hex(ki, op).upper()


def xor_str(s, t):
    return bytes([_a ^ _b for _a, _b in zip(s, t)])


def calc_opc_hex(k_hex: str, op_hex: str) -> str:
    """Calculation of OPc from ki(Secret key) and OP ( Operator Variant Algorithm Configuration Field OP)
    Reference:  TS 135 206 - V14.0.0 Standard

    Args:
        k_hex (str): Secret key
        op_hex (str): OP key

    Returns:
        str: OPc
    """

    iv = binascii.unhexlify(16 * "00")
    ki = binascii.unhexlify(k_hex)
    op = binascii.unhexlify(op_hex)
    # ===========================#
    # =========E[OP]k============#
    # ===========================#

    aes_crypt = AES.new(ki, mode=AES.MODE_CBC, IV=iv)

    data = op
    # ===========================#
    # ========E[OP]k^OP==========#
    # ===========================#
    o_pc = xor_str(data, aes_crypt.encrypt(data))
    return o_pc.hex().upper()


def gen_eki(transport, ki):
    return aes_128_cbc_encrypt(transport, ki)


def gen_opc_eki(op, transport, ki):
    return {"opc": gen_opc(op, ki), "eki": gen_eki(transport, ki)}


def lenfunc(x):
    return len(x)


def generate_8_Digit():
    return str(secrets.SystemRandom().randint(10000000, 99999999))


# def generate_16_Digit():
#     return str(secrets.SystemRandom().randint(1000000000000000, 9999999999999999))


def generate_4_Digit():
    return str(secrets.SystemRandom().randint(1000, 9999))


def enc_pin_func(x):
    return rpad(s2h(x), 16).upper()


def dec_pin_func(x):
    return (h2s(x)).upper()


def enc_imsi(imsi):
    imsi = str(imsi)
    l = half_round_up(
        len(imsi) + 1
    )  # Required bytes - include space for odd/even indicator
    oe = len(imsi) & 1  # Odd (1) / Even (0)
    ei = "%02x" % l + swap_nibbles("%01x%s" % ((oe << 3) | 1, rpad(imsi, 15)))
    return ei


def dec_imsi(ef):
    ef = str(ef)
    if len(ef) < 4:
        return None
    l = int(ef[0:2], 16) * 2  # Length of the IMSI string
    l = l - 1  # Encoded length byte includes oe nibble
    swapped = swap_nibbles(ef[2:]).rstrip("f")
    if len(swapped) < 1:
        return None
    oe = (int(swapped[0]) >> 3) & 1  # Odd (1) / Even (0)
    if not oe:
        l = l - 1
    if l != len(swapped) - 1:
        return None
    imsi = swapped[1:]
    return imsi


Hexstr = str


def enc_iccid(iccid: str) -> Hexstr:
    iccid = str(iccid)
    luhn = calculate_luhn(iccid)
    iccid = iccid + str(luhn)
    m_iccid = swap_nibbles(rpad(iccid, 20))
    return m_iccid.upper()


def dec_iccid(ef: Hexstr) -> str:
    ef = str(ef)
    ef = ef.upper()
    iccid = swap_nibbles(ef).strip("F")
    return iccid[:-1]


def swap_nibbles(s: Hexstr) -> Hexstr:
    return "".join([x + y for x, y in zip(s[1::2], s[0::2])])


def rpad(s: str, l: int, c="f") -> str:
    return s + c * (l - len(s))


def lpad(s: str, l: int, c="f") -> str:
    return c * (l - len(s)) + s


def half_round_up(n: int) -> int:
    return (n + 1) // 2


def calculate_luhn(cc) -> int:
    num = list(map(int, str(cc)))
    check_digit = (
            10 - sum(num[-2::-2] + [sum(divmod(d * 2, 10)) for d in num[::-2]]) % 10
    )
    return 0 if check_digit == 10 else check_digit


def h2b(s: Hexstr) -> bytearray:
    return bytearray.fromhex(s)


def b2h(b: bytearray) -> Hexstr:
    return "".join(["%02x" % (x) for x in b])


def h2i(s: Hexstr) -> List[int]:
    return [(int(x, 16) << 4) + int(y, 16) for x, y in zip(s[0::2], s[1::2])]


def i2h(s: List[int]) -> Hexstr:
    return "".join(["%02x" % (x) for x in s])


def h2s(s: Hexstr) -> str:
    return "".join(
        [
            chr((int(x, 16) << 4) + int(y, 16))
            for x, y in zip(s[0::2], s[1::2])
            if int(x + y, 16) != 0xFF
        ]
    )


def s2h(s: str) -> Hexstr:
    b = bytearray()
    b.extend(map(ord, s))
    return b2h(b)


def i2s(s: List[int]) -> str:
    return "".join([chr(x) for x in s])


def integer_2_ascii(x):
    return s2h(x)


def ascii_2_integer(x):
    return h2s(str(x))


def apply_luhn_check(x):
    return str(x) + str(calculate_luhn(str(x)))


def copy_function(x):
    return str(x)


#  return str("0002")


# code below is for Demo Data generation, what if we have to gernate Data from ICCID and IMSI given
# we have to read input file and copy content [ICCID, IMSI] from input file and generate Parameters based on input File


# def read_json(file_path: str):
#     with open(file_path, "r") as json_file:
#         data = json.load(json_file)
#     return dict(data)


def read_json(file_path: str):
    try:
        with open(file_path, "r") as json_file:
            data = json.load(json_file)
        return dict(data)
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
        return None  # You can choose to return None or raise a custom exception here
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON in '{file_path}': {e}")
        return None  # You can choose to return None or raise a custom exception here


class DataGenerationScript:
    def __init__(self) -> None:
        self.params = PARAMETERS.get_instance()
        self.dataframes = DATA_FRAMES.get_instance()

    def __gen_eki_custom(self, x):
        return gen_eki(self.params.get_K4(), x)

    def __gen_opc_custom(self, x):
        return gen_opc(self.params.get_OP(), x)

    def __PIN1_function(self, x):
        return str(self.params.get_PIN1())

    def __PUK1_function(self, x):
        return str(self.params.get_PUK1())

    def __PIN2_function(self, x):
        return str(self.params.get_PIN2())

    def __PUK2_function(self, x):
        return str(self.params.get_PUK2())

    def __ADM1_function(self, x):
        return str(self.params.get_ADM1())

    def __ADM6_function(self, x):
        return str(self.params.get_ADM6())

    @staticmethod
    def __ACC_function(imsi: str) -> str:
        last_digit = int(imsi[-1])
        acc_binary = bin(1 << last_digit)[2:].zfill(16)
        return format(int(acc_binary, 2), "04x")

    @staticmethod
    def __splitter(input_string):
        if (
                (input_string != "")
                and (input_string.find("-") != -1)
                and len(input_string) > 2
        ):
            values = input_string.split("-")
        else:
            values = [0, 32]
        return int(values[0]), int(values[1])

    def __extract_values(self, t: list):
        R = []
        L = []
        for i in t:
            left, right = self.__splitter(i)
            R.append(right)
            L.append(left)
        return L, R

    @staticmethod
    def __return_diplicates(x):
        return [item for item, count in collections.Counter(x).items() if count > 1]

    def __get_dic_parameter(self, d: dict):
        va, cl, R, L = ([] for i in range(4))
        for i in range(len(d.keys())):
            va.append(list(d.values())[i][0])
            cl.append(list(d.values())[i][1])
            R1, L1 = self.__splitter(list(d.values())[i][2])
            R.append(R1)
            L.append(L1)
        va_renamed = self.__append_count_to_duplicates(va)
        va_duplicate = self.__return_diplicates(va)
        va_unique = set(va)
        return va_renamed, va_duplicate, va_unique, cl, R, L

    @staticmethod
    def __Generate_df_from_list(t_list: list, rows: int):
        df = pd.DataFrame()
        d1 = {}
        for i in range(len(t_list)):
            d1[str(t_list[i])] = 0
        new_data = [d1 for i in range(0, rows)]
        df = pd.concat([df, pd.DataFrame(new_data)], ignore_index=True)
        return df

    @staticmethod
    def __append_count_to_duplicates(input_list):
        output_list = []
        element_counts = {}

        for element in input_list:
            if element in element_counts:
                element_counts[element] += 1
                output_list.append(f"{element}{element_counts[element]}")
            else:
                element_counts[element] = 0
                output_list.append(element)

        return output_list

    @staticmethod
    def __Init_major(df, str1, init_v):
        for i in range(0, df.shape[0]):
            # df.loc[i, str1] = str(init_v + i)
            df.loc[i, str1] = int(init_v + i)

    @staticmethod
    def __Init_minor(df, str1, init_v):
        df[str1] = str(init_v)

    def __InitalizeDemoDataFrame(self, df, demo: bool, ICCID_start, IMSI_start):
        if demo is True:
            self.__Init_major(df, "ICCID", ICCID_start)  # major with incremetal pattern
            self.__Init_major(df, "IMSI", IMSI_start)
        else:
            self.__Init_major(df, "ICCID", 0)  # major without incremetal pattern
            self.__Init_major(df, "IMSI", 0)

        self.__Init_major(df, "PIN1", 0)
        self.__Init_major(df, "PUK1", 0)
        self.__Init_major(df, "PIN2", 0)
        self.__Init_major(df, "PUK2", 0)
        self.__Init_major(df, "KI", 0)
        self.__Init_major(df, "EKI", 0)
        self.__Init_major(df, "ADM1", 0)
        self.__Init_major(df, "ADM6", 0)
        self.__Init_major(df, "OPC", 0)
        self.__Init_major(df, "ACC", 0)
        #  df['len_KI'] = 0
        #  df['len_EKI'] = 0
        #  df['len_OPC'] = 0
        return df

    @staticmethod
    def __apply_function(df, dest: str, src: str, function):
        if dest in df.columns:
            df[dest] = df[src].apply(function).copy(deep=False)

    def __Apply_functions(self, df, op_1, k4_1):
        #  print(k4_1,op_1)
        #  apply_function(df,'ICCID','ICCID',apply_luhn_check)
        self.__apply_function(df, "ICCID", "ICCID", copy_function)
        self.__apply_function(df, "IMSI", "IMSI", copy_function)

        if self.params.get_PIN1_RAND() is False:
            self.__apply_function(
                df, "PIN1", "PIN1", lambda x: generate_4_Digit()
            )  # Reason: PIN1 is fixed for now
        else:
            self.__apply_function(
                df, "PIN1", "PIN1", self.__PIN1_function
            )  # Reason: PIN1 is fixed for now

        if self.params.get_PUK1_RAND() is False:
            self.__apply_function(df, "PUK1", "PUK1", lambda x: generate_8_Digit())
        else:
            self.__apply_function(df, "PUK1", "PUK1", self.__PUK1_function)

        if self.params.get_PIN2_RAND() is False:
            self.__apply_function(df, "PIN2", "PIN2", lambda x: generate_4_Digit())
        else:
            self.__apply_function(df, "PIN2", "PIN2", self.__PIN2_function)

        if self.params.get_PUK2_RAND() is False:
            self.__apply_function(df, "PUK2", "PUK2", lambda x: generate_8_Digit())
        else:
            self.__apply_function(df, "PUK2", "PUK2", self.__PUK2_function)

        if self.params.get_ADM1_RAND() is False:
            self.__apply_function(df, "ADM1", "ADM1", lambda x: generate_8_Digit())
        else:
            self.__apply_function(df, "ADM1", "ADM1", self.__ADM1_function)

        if self.params.get_ADM6_RAND() is False:
            self.__apply_function(df, "ADM6", "ADM6", lambda x: generate_8_Digit())
        else:
            self.__apply_function(df, "ADM6", "ADM6", self.__ADM6_function)

        self.__apply_function(df, "KI", "KI", lambda x: gen_ki())
        self.__apply_function(df, "EKI", "KI", self.__gen_eki_custom)
        #        self.__apply_function(df, "OPC", "EKI", self.__gen_opc_custom)
        self.__apply_function(df, "OPC", "KI", self.__gen_opc_custom)
        """ Change made on 30-10-2023 by hamza originally it was as commented """

        self.__apply_function(df, "KIC1", "KI", lambda x: gen_otas())
        self.__apply_function(df, "KIC2", "KI", lambda x: gen_otas())
        self.__apply_function(df, "KIC3", "KI", lambda x: gen_otas())

        self.__apply_function(df, "KID1", "KI", lambda x: gen_otas())
        self.__apply_function(df, "KID2", "KI", lambda x: gen_otas())
        self.__apply_function(df, "KID3", "KI", lambda x: gen_otas())

        self.__apply_function(df, "KIK1", "KI", lambda x: gen_otas())
        self.__apply_function(df, "KIK2", "KI", lambda x: gen_otas())
        self.__apply_function(df, "KIK3", "KI", lambda x: gen_otas())

        self.__apply_function(df, "ACC", "IMSI", self.__ACC_function)

        return df

    @staticmethod
    def __drop_extra_columns(list_pass: list, dataframe):
        columns_to_drop = [col for col in dataframe.columns if col not in list_pass]
        data = dataframe.drop(columns=columns_to_drop).copy(deep=False)
        return data

    @staticmethod
    def __Clip_columns(df, l: list, r: list):
        count = 0
        dict2 = {}
        for col in df.columns:
            dict2[col] = count
            count += 1
        for col in df.columns:
            df[col] = (
                df[col]
                .apply(lambda x: x[l[dict2[col]]: r[dict2[col]] + 1])
                .copy(deep=False)
            )
        return df

    @staticmethod
    def __add_duplicate_var(df, limit: int, h1: list):
        for c in range(limit):
            for col in default_headers:
                if col + str(c) in h1:
                    df[col + str(c)] = df[col].copy(deep=False)
        return df[h1]  # df[h] reason: to return index of df according to header

    @staticmethod
    def __Encoding(df):
        if "ICCID" in df.columns:
            df["ICCID"] = df["ICCID"].apply(enc_iccid).copy(deep=False)
        if "IMSI" in df.columns:
            df["IMSI"] = df["IMSI"].apply(enc_imsi).copy(deep=False)
        if "PIN1" in df.columns:
            df["PIN1"] = df["PIN1"].apply(enc_pin_func).copy(deep=False)
        if "PUK1" in df.columns:
            df["PUK1"] = df["PUK1"].apply(integer_2_ascii).copy(deep=False)
        if "PIN2" in df.columns:
            df["PIN2"] = df["PIN2"].apply(enc_pin_func).copy(deep=False)
        if "PUK2" in df.columns:
            df["PUK2"] = df["PUK2"].apply(integer_2_ascii).copy(deep=False)
        if "ADM1" in df.columns:
            df["ADM1"] = df["ADM1"].apply(integer_2_ascii).copy(deep=False)
        if "ADM1" in df.columns:
            df["ADM6"] = df["ADM6"].apply(integer_2_ascii).copy(deep=False)
        return df

    @staticmethod
    def __Decoding(df):
        if "ICCID" in df.columns:
            df["ICCID"] = df["ICCID"].apply(dec_iccid).copy(deep=False)
        if "IMSI" in df.columns:
            df["IMSI"] = df["IMSI"].apply(dec_imsi).copy(deep=False)
        if "PIN1" in df.columns:
            df["PIN1"] = df["PIN1"].apply(dec_pin_func).copy(deep=False)
        if "PUK1" in df.columns:
            df["PUK1"] = df["PUK1"].apply(ascii_2_integer).copy(deep=False)
        if "PIN2" in df.columns:
            df["PIN2"] = df["PIN2"].apply(dec_pin_func).copy(deep=False)
        if "PUK2" in df.columns:
            df["PUK2"] = df["PUK2"].apply(ascii_2_integer).copy(deep=False)
        if "ADM1" in df.columns:
            df["ADM1"] = df["ADM1"].apply(ascii_2_integer).copy(deep=False)
        return df

    def __non_demo(self, default_headers1, op_3, k4_3):
        # data = self.dataframes.INPUT_DF
        data = self.dataframes.get_INPUT_DF()

        df1 = self.__Generate_df_from_list(default_headers1, data.shape[0])
        # df3 = InitalizeDemoDataFrame(df2,demo=demo_Data)
        #  print([(c, data[c].dtype.kind in 'iufcb') for c in data.columns])
        df1["ICCID"] = data["ICCID"]
        df1["IMSI"] = data["IMSI"]
        #  print("length of ICCID and IMSI are {} {}".format(len(data['IMSI']),len(data['ICCID'])))
        #  print("Data of ICCID and IMSI are {} {}".format((data['IMSI']),(data['ICCID'])))
        non_demo_data = self.__Apply_functions(df1, op_3, k4_3)
        return non_demo_data

    def __is_demo(self, default_headers1, op_3: str, k4_3: str):
        #  empty_df = Generate_df_from_list(default_headers1,int(size))
        empty_df = self.__Generate_df_from_list(
            default_headers1, int(self.params.get_DATA_SIZE())
        )
        demo_data_init = self.__InitalizeDemoDataFrame(
            empty_df,
            demo=True,
            ICCID_start=int(self.params.get_ICCID()),
            IMSI_start=int(self.params.get_IMSI()),
        )
        demo_data = self.__Apply_functions(demo_data_init, op_3, k4_3)
        return demo_data

    def __DATA_PARSER_INITIAL(
            self, demo_data1: bool, default_headers2: list, op_4, k4_4, keys: bool
    ):
        if keys:
            dict_keys = {"k4": k4_4, "op": op_4}
        else:
            dict_keys = {"k4": "", "op": ""}
        if demo_data1 is True:
            return self.__is_demo(default_headers2, op_4, k4_4), dict_keys

        if demo_data1 is False:
            return self.__non_demo(default_headers2, op_4, k4_4), dict_keys

    def __DATA_PARSER_FINAL(
            self, input_dict: dict, df_input, clip: bool, encoding: bool, caption: str
    ):
        (
            laser_h,
            laser_d_h,
            laser_unique,
            laser_c,
            laser_l,
            laser_r,
        ) = self.__get_dic_parameter(input_dict)
        df20 = df_input.copy(deep=False)
        if encoding is True:
            emcoded_df = self.__Encoding(df20)
        else:
            emcoded_df = df20.copy(deep=False)
        #  print(laser_l)
        #  print(laser_r)

        dupl_var_encoded_df = self.__add_duplicate_var(emcoded_df, 10, laser_h)
        dupl_var_encoded_df = dupl_var_encoded_df.copy(deep=False)
        # df23 = drop_extra_columns(laser_h,df7)
        # df24 = df22.copy(deep=False)
        if clip is True:
            final_df = self.__Clip_columns(dupl_var_encoded_df, laser_l, laser_r)
        else:
            final_df = dupl_var_encoded_df.copy(deep=False)
        #  final_df.style.set_caption("|=="+caption+"==|")
        return final_df

    def __LASER_DATA_EXTRACTOR(
            self, input_dict: dict, df_input, clip: bool, encoding: bool, caption: str
    ):
        (
            laser_h,
            laser_d_h,
            laser_unique,
            laser_c,
            laser_l,
            laser_r,
        ) = self.__get_dic_parameter(input_dict)
        df20 = df_input.copy(deep=False)
        if encoding is True:
            emcoded_df = self.__Decoding(df20)
        else:
            emcoded_df = df20.copy(deep=False)
        #  print(laser_l)
        #  print(laser_r)

        dupl_var_encoded_df = self.__add_duplicate_var(emcoded_df, 10, laser_h)
        dupl_var_encoded_df = dupl_var_encoded_df.copy(deep=False)
        # df23 = drop_extra_columns(laser_h,df7)
        # df24 = df22.copy(deep=False)
        if clip is True:
            final_df = self.__Clip_columns(dupl_var_encoded_df, laser_l, laser_r)
        else:
            final_df = dupl_var_encoded_df.copy(deep=False)
        #  final_df.style.set_caption("|=="+caption+"==|")
        return final_df

    # ===========================================#
    # ===================SET=====================#
    # ===========================================#
    def SET_ALL_DISP_PARAMS(self):
        self.params.set_K4(
            "111150987DE41E9F0808193003B543296D0A01D797B511AFDAEEEAC53BC61111"
        )
        self.params.set_OP("1111006F86FAD6540D86FEF24D261111")
        self.params.set_IMSI(999990000000400)
        self.params.set_ICCID(999900000000000400)
        self.params.set_PIN1("0000")
        self.params.set_PUK1("00000000")
        self.params.set_PIN2("5555")
        self.params.set_PUK2("4444")
        self.params.set_ADM1("11111111")
        self.params.set_ADM6("11111111")
        self.params.set_ACC("0111")
        self.params.set_DATA_SIZE(7)

        self.params.set_PRODUCTION_CHECK(False)
        self.params.set_ELECT_CHECK(True)
        self.params.set_GRAPH_CHECK(True)
        self.params.set_SERVER_CHECK(True)

        # self.params.set_SERVER_DICT(input_server_params)
        # self.params.set_ELECT_DICT(input_elect_params)
        # self.params.set_GRAPH_DICT(input_laser_params)
        #  params.set_INPUT_PATH("C:/Users/hamza.qureshi/Desktop/STC_APP/improvements/dataGen-v17/input.csv")
        self.params.set_INPUT_PATH("templates/N2023031016844011.txt")

        # ========================================#
        # ========================================#
        # ========================================#

        self.params.set_PIN1_RAND(False)
        self.params.set_PUK1_RAND(True)
        self.params.set_PIN2_RAND(False)
        self.params.set_PUK2_RAND(False)
        self.params.set_ADM1_RAND(False)
        self.params.set_ADM6_RAND(True)
        self.params.set_ACC_RAND(False)

    # ===========================================#
    # ==================GET======================#
    # ===========================================#

    # parameter_dict={
    #   "Demo Data":"","OP":"","K4":"","ICCID":"","IMSI":"",
    #   "PIN1":"","PUK1":"","PIN2":"","PUK2":"","ADM1":"",
    #   "ADM6":"","ACC":"","DATA_SIZE":""}
    def GET_ALL_PARAMS_DICT(self) -> dict:
        param_dict = {}
        param_dict["Demo Data"] = self.params.get_PRODUCTION_CHECK()
        param_dict["OP"] = self.params.get_OP()
        param_dict["K4"] = self.params.get_K4()
        param_dict["ICCID"] = self.params.get_ICCID()
        param_dict["IMSI"] = self.params.get_IMSI()
        param_dict["PIN1"] = self.params.get_PIN1()
        param_dict["PUK1"] = self.params.get_PUK1()
        param_dict["PIN2"] = self.params.get_PIN2()
        param_dict["PUK2"] = self.params.get_PUK2()
        param_dict["ADM1"] = self.params.get_ADM1()
        param_dict["ADM6"] = self.params.get_ADM6()
        param_dict["ACC"] = self.params.get_ACC()
        param_dict["DATA_SIZE"] = self.params.get_DATA_SIZE()
        param_dict["INPUT_PATH"] = self.params.get_INPUT_PATH()
        return param_dict

    def _preview_files_gets(self):
        Initial_DataFrame = pd.DataFrame()
        Initial_DataFrame, keys_dict = self.__DATA_PARSER_INITIAL(
            demo_data1=self.params.get_PRODUCTION_CHECK(),
            default_headers2=default_headers,
            op_4=self.params.get_OP(),
            k4_4=self.params.get_K4(),
            keys=True,
        )
        print("Keys used in this data generation attempt are : ")
        print(keys_dict)
        laser_df = pd.DataFrame()
        elect_df = pd.DataFrame()
        server_df = pd.DataFrame()

        if self.params.get_SERVER_CHECK() is True:
            server_df = self.__DATA_PARSER_FINAL(
                self.params.get_SERVER_DICT(),
                Initial_DataFrame,
                clip=False,
                encoding=False,
                caption="SERVER",
            )
        if self.params.get_GRAPH_CHECK() is True:
            laser_df = self.__DATA_PARSER_FINAL(
                self.params.get_GRAPH_DICT(),
                Initial_DataFrame,
                clip=True,
                encoding=False,
                caption="LASER",
            )
        if self.params.get_ELECT_CHECK() is True:
            elect_df = self.__DATA_PARSER_FINAL(
                self.params.get_ELECT_DICT(),
                Initial_DataFrame,
                clip=False,
                encoding=True,
                caption="ELECT",
            )

        return elect_df, laser_df, server_df, keys_dict

    def SET_HEADERS(self):
        # this must not be here | remove in revision
        factory_data_json_path = CONFIGURATION_FILE_PATH
        try:
            data = read_json(factory_data_json_path)
            if data:
                header_server_dict = list_2_dict(data["PARAMETERS"]["server_variables"])
                headers_laser_dict = data["PARAMETERS"]["laser_variables"]
                headers_data_dict = list_2_dict(data["PARAMETERS"]["data_variables"])

                self.params.set_SERVER_DICT(header_server_dict)
                self.params.set_ELECT_DICT(headers_data_dict)
                self.params.set_GRAPH_DICT(headers_laser_dict)
                return "Loaded Json Successfull!"
            return "Loaded Json Unuccessfull!"
        except Exception as e:
            return e


# input_laser_params = {
#     "0": ["ICCID", "Right", "0-31"],
#     "1": ["ICCID", "Right", "0-31"],
#     "2": ["ICCID", "Right", "0-31"],
#     "3": ["ICCID", "Right", "0-31"],
#     "4": ["ICCID", "Right", "0-31"],
#     "5": ["IMSI", "Right", "0-31"],
#     "6": ["IMSI", "Right", "0-31"],
# }
# input_server_params = {}
# input_elect_params = {
#     "0": ["ICCID", "Normal", "0-19"],
#     "1": ["IMSI", "Normal", "0-14"],
#     "2": ["PIN1", "Normal", "0-3"],
#     "3": ["PUK1", "Normal", "0-7"],
#     "5": ["PIN2", "Normal", "0-3"],
#     "6": ["PUK2", "Normal", "0-7"],
#     "7": ["ADM1", "Normal", "0-7"],
#     "8": ["ADM6", "Normal", "0-7"],
#     "10": ["EKI", "Normal", "0-31"],
#     "11": ["OPC", "Normal", "0-31"],
#     "12": ["ACC", "Normal", "0-3"],
# }


# ==============================================================#
# ========================LASER DATA============================#
# ==============================================================#


# ==============================================================#
# =====================ELECTRICAL DATA==========================#
# ==============================================================#


def list_2_dict(list: list) -> dict:
    dict = {}
    for index in range(0, len(list)):
        dict[str(index)] = [list[index], "Normal", "0-31"]
    return dict


def dict_2_list(d: dict) -> list:
    list1 = []
    for index, j in enumerate(d):
        temp = list(d.values())[index][0]
        list1.append(temp)
    return list1


# # input_elect_params = {
# #     "0": ["ICCID", "Normal", "0-18"],
# #     "1": ["ICCID", "Normal", "10-20"],
# #     "2": ["ICCID", "Normal", "0-14"],
# #     "3": ["IMSI", "Normal", "0-14"],
# #     "4": ["PIN1", "Normal", "0-14"],
# # }


# from operators.zong.FileParser import ZongFileParser
# from json_utils import JsonHandler
#
# s = DataGenerationScript()
# j = JsonHandler()
# factory_data_json_path = CONFIGURATION_FILE_PATH
# j.read_paths()
# j.read_variables()
# s.SET_ALL_DISP_PARAMS()  # testing
# s.SET_HEADERS()
#
# (
#     s.dataframes.__ELECT_DF,
#     s.dataframes.__GRAPH_DF,
#     s.dataframes.__SERVR_DF,
#     s.dataframes.__KEYS,
# ) = s._preview_files_gets()
#
# print(s.dataframes.__ELECT_DF)
# print(s.dataframes.__GRAPH_DF)
# print(s.dataframes.__SERVR_DF)
#
# # # m_zong = ZongGenerateHandle()
#
# # # m_zong.set_json_to_UI()
# # # m_zong.Generate_laser_file("AAA",s.dataframes.GRAPH_DF)
# # # m_zong.Generate_servr_file("ASD",s.dataframes.SERVR_DF)
# # # m_zong.Generate_elect_file("ASD",s.dataframes.ELECT_DF)
