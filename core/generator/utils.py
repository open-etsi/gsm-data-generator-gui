"""
STC_APP_Scriptv6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nz_MGqPs5z1rz_G6NBl8xH-dQJxeK1Z3 : Private
    Author : Hamza Qureshi

DESCRIPTION
This code include following :
1. Create demo data dynamic method
2. Generate all parameters added by user from Application/settings.json[Working Fine]
3. Get input file
4. Create output CSV or Text files [data, laser and server files] as well
"""

# !pip install pycryptodome
# you can use requirements.txt
# from core.GlobalParams import PARAMETERS, DATA_FRAMES
# from GlobalParams import PARAMETERS, DATA_FRAMES
from globals.parameters import PARAMETERS, DATA_FRAMES

# from custom_json import JsonHandler
from typing import Optional, List, Dict, Any, Tuple

# from pydantic import BaseModel, Field
from Crypto.Cipher import AES
from io import BytesIO
import secrets
import pandas as pd
import collections
import binascii
import datetime
import random
import string
import uuid
import json
import time
import os

CONFIGURATION_FILE_PATH = "settings.json"

default_headers = (
    "ICCID",
    "IMSI",
    "OP",
    "K4",
    "PIN1",
    "PUK1",
    "PIN2",
    "PUK2",
    "KI",
    "EKI",
    "OPC",
    "ADM1",
    "ADM6",
    "ACC",
    "KIC1",
    "KID1",
    "KIK1",
    "KIC2",
    "KID2",
    "KIK2",
    "KIC3",
    "KID3",
    "KIK3",
)


class CryptoUtils:
    @staticmethod
    def aes_128_cbc_encrypt(key: str, text: str) -> str:
        iv = binascii.unhexlify("00000000000000000000000000000000")
        key_bytes = binascii.unhexlify(key)
        text_bytes = binascii.unhexlify(text)
        encryptor = AES.new(key_bytes, AES.MODE_CBC, IV=iv)
        ciphertext = encryptor.encrypt(text_bytes)
        return ciphertext.hex().upper()

    @staticmethod
    def xor_str(s: bytes, t: bytes) -> bytes:
        return bytes([_a ^ _b for _a, _b in zip(s, t)])

    @staticmethod
    def calc_opc_hex(k_hex: str, op_hex: str) -> str:
        iv = binascii.unhexlify(16 * "00")
        ki = binascii.unhexlify(k_hex)
        op = binascii.unhexlify(op_hex)
        aes_crypt = AES.new(ki, mode=AES.MODE_CBC, IV=iv)
        data = op
        o_pc = CryptoUtils.xor_str(data, aes_crypt.encrypt(data))
        return o_pc.hex().upper()


class DataGenerator:
    @staticmethod
    def generate_ki() -> str:
        return secrets.token_hex(16).upper()

    @staticmethod
    def generate_otas() -> str:
        return secrets.token_hex(16).upper()

    @staticmethod
    def generate_k4() -> str:
        return secrets.token_hex(32).upper()

    @staticmethod
    def generate_8_digit() -> str:
        return str(secrets.SystemRandom().randint(10000000, 99999999))

    @staticmethod
    def generate_4_digit() -> str:
        return str(secrets.SystemRandom().randint(1000, 9999))

    @staticmethod
    def generate_opc(op: str, ki: str) -> str:
        return CryptoUtils.calc_opc_hex(ki, op).upper()

    @staticmethod
    def generate_eki(transport: str, ki: str) -> str:
        return CryptoUtils.aes_128_cbc_encrypt(transport, ki)


def copy_function(x):
    return str(x)


#  return str("0002")


# code below is for Demo Data generation, what if we have to gernate Data from ICCID and IMSI given
# we have to read input file and copy content [ICCID, IMSI] from input file and generate Parameters based on input File


# def read_json(file_path: str):
#     with open(file_path, "r") as json_file:
#         data = json.load(json_file)
#     return dict(data)


class EncodingUtils:
    @staticmethod
    def enc_pin(pin: str) -> str:
        return EncodingUtils.rpad(EncodingUtils.s2h(pin), 16).upper()

    @staticmethod
    def dec_pin(encoded_pin: str) -> str:
        return EncodingUtils.h2s(encoded_pin).upper()

    @staticmethod
    def enc_imsi(imsi):
        imsi = str(imsi)
        l = EncodingUtils.half_round_up(len(imsi) + 1)  # Required bytes - include space for odd/even indicator
        oe = len(imsi) & 1  # Odd (1) / Even (0)
        ei = "%02x" % l + EncodingUtils.swap_nibbles("%01x%s" % ((oe << 3) | 1, EncodingUtils.rpad(imsi, 15)))
        return ei

    @staticmethod
    def dec_imsi(ef: str) -> Optional[str]:
        if len(ef) < 4:
            return None
        l = int(ef[0:2], 16) * 2 - 1
        swapped = EncodingUtils.swap_nibbles(ef[2:]).rstrip("f")
        if len(swapped) < 1:
            return None
        oe = (int(swapped[0]) >> 3) & 1
        if not oe:
            l -= 1
        if l != len(swapped) - 1:
            return None
        return swapped[1:]

    @staticmethod
    def enc_iccid(iccid: str) -> str:
        luhn = EncodingUtils.calculate_luhn(iccid)
        iccid_with_luhn = iccid + str(luhn)
        return EncodingUtils.swap_nibbles(
            EncodingUtils.rpad(iccid_with_luhn, 20)
        ).upper()

    @staticmethod
    def dec_iccid(ef: str) -> str:
        return EncodingUtils.swap_nibbles(ef.upper()).strip("F")[:-1]

    @staticmethod
    def swap_nibbles(s: str) -> str:
        return "".join([x + y for x, y in zip(s[1::2], s[0::2])])

    @staticmethod
    def rpad(s: str, l: int, c: str = "f") -> str:
        return s + c * (l - len(s))

    @staticmethod
    def lpad(s: str, l: int, c: str = "f") -> str:
        return c * (l - len(s)) + s

    @staticmethod
    def half_round_up(n: int) -> int:
        return (n + 1) // 2

    @staticmethod
    def calculate_luhn(cc: str) -> int:
        num = list(map(int, str(cc)))
        check_digit = (
            10 - sum(num[-2::-2] + [sum(divmod(d * 2, 10)) for d in num[::-2]]) % 10
        )
        return 0 if check_digit == 10 else check_digit

    @staticmethod
    def h2b(s: str) -> bytearray:
        return bytearray.fromhex(s)

    @staticmethod
    def b2h(b: bytearray) -> str:
        return "".join([f"{x:02x}" for x in b])

    @staticmethod
    def h2i(s: str) -> List[int]:
        return [(int(x, 16) << 4) + int(y, 16) for x, y in zip(s[0::2], s[1::2])]

    @staticmethod
    def i2h(s: List[int]) -> str:
        return "".join([f"{x:02x}" for x in s])

    @staticmethod
    def h2s(s: str) -> str:
        return "".join(
            [
                chr((int(x, 16) << 4) + int(y, 16))
                for x, y in zip(s[0::2], s[1::2])
                if int(x + y, 16) != 0xFF
            ]
        )

    @staticmethod
    def s2h(s: str) -> str:
        return EncodingUtils.b2h(bytearray(map(ord, s)))

    @staticmethod
    def i2s(s: List[int]) -> str:
        return "".join([chr(x) for x in s])


class DataProcessing:
    @staticmethod
    def generate_acc(imsi: str) -> str:
        last_digit = int(imsi[-1])
        acc_binary = bin(1 << last_digit)[2:].zfill(16)
        return format(int(acc_binary, 2), "04x")

    @staticmethod
    def split_range(input_string: str) -> Tuple[int, int]:
        if input_string and "-" in input_string and len(input_string) > 2:
            values = input_string.split("-")
            return int(values[0]), int(values[1])
        return 0, 32

    @staticmethod
    def extract_ranges(ranges: List[str]) -> Tuple[List[int], List[int]]:
        left_ranges, right_ranges = [], []
        for range_str in ranges:
            left, right = DataProcessing.split_range(range_str)
            left_ranges.append(left)
            right_ranges.append(right)
        return left_ranges, right_ranges

    @staticmethod
    def find_duplicates(items: List[Any]) -> List[Any]:
        return [item for item, count in collections.Counter(items).items() if count > 1]

    @staticmethod
    def extract_parameter_info(
        param_dict: Dict[str, List[str]]
    ) -> Tuple[List[str], List[str], set, List[str], List[int], List[int]]:
        values, classes, ranges = [], [], []
        for item in param_dict.values():
            values.append(item[0])
            classes.append(item[1])
            ranges.append(item[2])

        renamed_values = DataProcessing.append_count_to_duplicates(values)
        duplicate_values = DataProcessing.find_duplicates(values)
        unique_values = set(values)
        left_ranges, right_ranges = DataProcessing.extract_ranges(ranges)

        return (
            renamed_values,
            duplicate_values,
            unique_values,
            classes,
            left_ranges,
            right_ranges,
        )

    @staticmethod
    def append_count_to_duplicates(input_list: List[str]) -> List[str]:
        output_list = []
        element_counts: Dict[str, int] = {}

        for element in input_list:
            if element in element_counts:
                element_counts[element] += 1
                output_list.append(f"{element}{element_counts[element]}")
            else:
                element_counts[element] = 0
                output_list.append(element)

        return output_list


class DataFrameProcessor:
    @staticmethod
    def generate_empty_dataframe(columns: List[str], rows: str) -> pd.DataFrame:
        empty_data = [{col: 0 for col in columns} for _ in range(int(rows))]
        return pd.DataFrame(empty_data)

    @staticmethod
    def initialize_column(
        df: pd.DataFrame, column: str, start_value: str, increment: bool = True
    ) -> None:
        if increment:
            df[column] = range(int(start_value), int(start_value) + len(df))
        else:
            df[column] = str(start_value)

    @staticmethod
    def apply_function_to_column(
        df: pd.DataFrame, dest_col: str, src_col: str, func: callable
    ) -> None:
        if dest_col in df.columns:
            df[dest_col] = df[src_col].apply(func)

    @staticmethod
    def clip_columns(
        df: pd.DataFrame, left_ranges: List[int], right_ranges: List[int]
    ) -> pd.DataFrame:
        for col, left, right in zip(df.columns, left_ranges, right_ranges):
            df[col] = df[col].apply(lambda x: x[left : right + 1])
        return df

    @staticmethod
    def add_duplicate_columns(
        df: pd.DataFrame, limit: int, headers: List[str]
    ) -> pd.DataFrame:
        for c in range(limit):
            for col in df.columns:
                new_col = f"{col}{c}"
                if new_col in headers:
                    df[new_col] = df[col]
        return df[headers]

    @staticmethod
    def encode_dataframe(df: pd.DataFrame) -> pd.DataFrame:
        encoding_map = {
            "ICCID": EncodingUtils.enc_iccid,
            "IMSI": EncodingUtils.enc_imsi,
            "PIN1": EncodingUtils.enc_pin,
            "PUK1": EncodingUtils.s2h,
            "PIN2": EncodingUtils.enc_pin,
            "PUK2": EncodingUtils.s2h,
            "ADM1": EncodingUtils.s2h,
            "ADM6": EncodingUtils.s2h,
        }
        for col, func in encoding_map.items():
            if col in df.columns:
                df[col] = df[col].apply(func)
        return df

    @staticmethod
    def decode_dataframe(df: pd.DataFrame) -> pd.DataFrame:
        decoding_map = {
            "ICCID": EncodingUtils.dec_iccid,
            "IMSI": EncodingUtils.dec_imsi,
            "PIN1": EncodingUtils.dec_pin,
            "PUK1": EncodingUtils.h2s,
            "PIN2": EncodingUtils.dec_pin,
            "PUK2": EncodingUtils.h2s,
            "ADM1": EncodingUtils.h2s,
        }
        for col, func in decoding_map.items():
            if col in df.columns:
                df[col] = df[col].apply(func)
        return df


# class STCAppParameters(BaseModel):
#     k4: str = Field(..., min_length=64, max_length=64)
#     op: str = Field(..., min_length=32, max_length=32)
#     imsi_start: int = Field(..., ge=100000000000000, le=999999999999999)
#     iccid_start: int = Field(..., ge=1000000000000000000, le=9999999999999999999)
#     pin1: str = Field(..., min_length=4, max_length=4)
#     puk1: str = Field(..., min_length=8, max_length=8)
#     pin2: str = Field(..., min_length=4, max_length=4)
#     puk2: str = Field(..., min_length=8, max_length=8)
#     adm1: str = Field(..., min_length=8, max_length=8)
#     adm6: str = Field(..., min_length=8, max_length=8)
#     acc: str = Field(..., min_length=4, max_length=4)
#     data_size: int = Field(..., gt=0)
#     production_check: bool
#     elect_check: bool
#     graph_check: bool
#     server_check: bool
#     input_path: str
#     pin1_rand: bool
#     puk1_rand: bool
#     pin2_rand: bool
#     puk2_rand: bool
#     adm1_rand: bool
#     adm6_rand: bool
#     acc_rand: bool
#     server_dict: Dict[str, List[str]]
#     elect_dict: Dict[str, List[str]]
#     graph_dict: Dict[str, List[str]]
#     input_df: Optional[pd.DataFrame] = None

# class STCAppScript:
#     def __init__(self):
#         self.params = {}
#         self.dataframes = {}

#     def set_parameters(self, params: Dict[str, Any]) -> None:
#         self.params = params

#     def generate_data(self) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, Dict[str, str]]:
#         initial_df, keys_dict = self._generate_initial_dataframe()

#         server_df = self._process_dataframe(initial_df, self.params['server_dict'], False, False, "SERVER")
#         laser_df = self._process_dataframe(initial_df, self.params['graph_dict'], True, False, "LASER")
#         elect_df = self._process_dataframe(initial_df, self.params['elect_dict'], False, True, "ELECT")

#         return elect_df, laser_df, server_df, keys_dict

#     def _generate_initial_dataframe(self) -> Tuple[pd.DataFrame, Dict[str, str]]:
#         default_headers = [
#             "ICCID", "IMSI", "PIN1", "PUK1", "PIN2", "PUK2", "KI", "EKI", "OPC",
#             "ADM1", "ADM6", "ACC", "KIC1", "KID1", "KIK1", "KIC2", "KID2", "KIK2",
#             "KIC3", "KID3", "KIK3"
#         ]

#         if self.params['production_check']:
#             df = DataFrameProcessor.generate_empty_dataframe(default_headers, self.params['data_size'])
#             DataFrameProcessor.initialize_column(df, "ICCID", self.params['iccid_start'])
#             DataFrameProcessor.initialize_column(df, "IMSI", self.params['imsi_start'])
#         else:
#             df = DataFrameProcessor.generate_empty_dataframe(default_headers, len(self.params['input_df']))
#             df["ICCID"] = self.params['input_df']["ICCID"]
#             df["IMSI"] = self.params['input_df']["IMSI"]

#         self._apply_data_generation_functions(df)

#         keys_dict = {"k4": self.params['k4'], "op": self.params['op']}
#         return df, keys_dict

#     def _apply_data_generation_functions(self, df: pd.DataFrame) -> None:
#         DataFrameProcessor.apply_function_to_column(df, "KI", "KI", DataGenerator.generate_ki)
#         DataFrameProcessor.apply_function_to_column(df, "EKI", "KI", lambda x: DataGenerator.generate_eki(self.params['k4'], x))
#         DataFrameProcessor.apply_function_to_column(df, )


def list_2_dict(list: list) -> dict:
    dict = {}
    for index in range(0, len(list)):
        dict[str(index)] = [list[index], "Normal", "0-31"]
    return dict


def dict_2_list(d: dict) -> list:
    list1 = []
    for index, j in enumerate(d):
        temp = list(d.values())[index][0]
        list1.append(temp)
    return list1


# # m_zong = ZongGenerateHandle()

# # m_zong.set_json_to_UI()
# # m_zong.Generate_laser_file("AAA",s.dataframes.GRAPH_DF)
# # m_zong.Generate_servr_file("ASD",s.dataframes.SERVR_DF)
# # m_zong.Generate_elect_file("ASD",s.dataframes.ELECT_DF)
