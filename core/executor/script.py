"""
STC_APP_Scriptv6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nz_MGqPs5z1rz_G6NBl8xH-dQJxeK1Z3 : Private
    Author : Hamza Qureshi

DESCRIPTION
This code include following :
1. Create demo data dynamic method
2. Generate all parameters added by user from Application/settings.json[Working Fine]
3. Get input file
4. Create output CSV or Text files [data, laser and server files] as well
"""

# !pip install pycryptodome
# you can use requirements.txt

# from core.GlobalParams import PARAMETERS, DATA_FRAMES

# Standard library imports
import binascii
import collections
import datetime
import json
import os
import random
import secrets
import string
import time
import uuid

# Third-party imports
import pandas as pd
from Crypto.Cipher import AES
from io import BytesIO

# Typing imports
from typing import Any, Dict, List, Optional, Tuple

# Project-specific imports
from core.generator.utils import (
    CryptoUtils,
    DataFrameProcessor,
    DataGenerator,
    DataProcessing,
)
from globals.parameters import DATA_FRAMES, PARAMETERS
from core.executor.utils import list_2_dict, dict_2_list, default_headers, copy_function
# Commented-out imports (if needed in the future)

class DataGenerationScript:

    def __init__(self, config_holder):
        self.config_holder = config_holder
        self.params = PARAMETERS.get_instance()
        self.dataframes = DATA_FRAMES.get_instance()
        self.crypto_utils = CryptoUtils()
        self.data_generator = DataGenerator()
        self.data_processor = DataProcessing()
        self.df_processor = DataFrameProcessor()

    def SET_ALL_DISP_PARAMS(self):
        self.params.set_SERVER_SEP(self.config_holder.DISP.server_data_sep)
        self.params.set_ELECT_SEP(self.config_holder.DISP.elect_data_sep)
        self.params.set_GRAPH_SEP(self.config_holder.DISP.graph_data_sep)
        self.params.set_K4(self.config_holder.DISP.K4)
        self.params.set_OP(self.config_holder.DISP.op)
        self.params.set_IMSI(self.config_holder.DISP.imsi)
        self.params.set_ICCID(self.config_holder.DISP.iccid)
        self.params.set_PIN1(self.config_holder.DISP.pin1)
        self.params.set_PUK1(self.config_holder.DISP.puk1)
        self.params.set_PIN2(self.config_holder.DISP.pin2)
        self.params.set_PUK2(self.config_holder.DISP.puk2)
        self.params.set_ADM1(self.config_holder.DISP.adm1)
        self.params.set_ADM6(self.config_holder.DISP.adm6)
        self.params.set_DATA_SIZE(self.config_holder.DISP.size)

        self.params.set_PRODUCTION_CHECK(False)
        self.params.set_ELECT_CHECK(self.config_holder.DISP.elect_check)
        self.params.set_GRAPH_CHECK(self.config_holder.DISP.graph_check)
        self.params.set_SERVER_CHECK(self.config_holder.DISP.server_check)

        self.params.set_SERVER_DICT(
            list_2_dict(self.config_holder.PARAMETERS.server_variables)
        )
        self.params.set_ELECT_DICT(list_2_dict(self.config_holder.PARAMETERS.data_variables))
        self.params.set_GRAPH_DICT((self.config_holder.PARAMETERS.laser_variables))
        #  params.set_INPUT_PATH("C:/Users/hamza.qureshi/Desktop/STC_APP/improvements/dataGen-v17/input.csv")
        self.params.set_INPUT_PATH(self.config_holder.PATHS.INPUT_FILE_PATH)

        # ========================================#
        # ========================================#
        # ========================================#

        self.params.set_PIN1_RAND(self.config_holder.DISP.pin1_fix)
        self.params.set_PUK1_RAND(self.config_holder.DISP.puk1_fix)
        self.params.set_PIN2_RAND(self.config_holder.DISP.pin2_fix)
        self.params.set_PUK2_RAND(self.config_holder.DISP.puk2_fix)
        self.params.set_ADM1_RAND(self.config_holder.DISP.adm1_fix)
        self.params.set_ADM6_RAND(self.config_holder.DISP.adm6_fix)
#        self.params.set_ACC_RAND(self.config_holder.DISP.pin1_rand)

    def generate_eki(self, ki):
        return self.data_generator.generate_eki(self.params.get_K4(), ki)

    def generate_opc(self, ki):
        return self.data_generator.generate_opc(self.params.get_OP(), ki)

    def generate_pin(self, pin_type):
        if getattr(self.params, f"get_{pin_type}_RAND")():
            return getattr(self.params, f"get_{pin_type}")()
        return self.data_generator.generate_4_digit()

    def generate_puk(self, puk_type):
        if getattr(self.params, f"get_{puk_type}_RAND")():
            return getattr(self.params, f"get_{puk_type}")()
        return self.data_generator.generate_8_digit()

    def generate_adm(self, adm_type):
        if getattr(self.params, f"get_{adm_type}_RAND")():
            return getattr(self.params, f"get_{adm_type}")()
        return self.data_generator.generate_8_digit()

    #    @staticmethod
    def apply_function(self, df, dest: str, src: str, function):
        if dest in df.columns:
            df[dest] = df[src].apply(function).copy(deep=False)

    def apply_functions(self, df):
        df["ICCID"] = df["ICCID"].apply(lambda x: copy_function(x))
        df["IMSI"] = df["IMSI"].apply(lambda x: copy_function(x))
        df["PIN1"] = df["PIN1"].apply(lambda x: self.generate_pin("PIN1"))
        df["PIN2"] = df["PIN2"].apply(lambda x: self.generate_pin("PIN2"))
        df["PUK1"] = df["PUK1"].apply(lambda x: self.generate_puk("PUK1"))
        df["PUK2"] = df["PUK2"].apply(lambda x: self.generate_puk("PUK2"))

        df["ADM1"] = df["ADM1"].apply(lambda x: self.generate_adm("ADM1"))
        df["ADM6"] = df["ADM6"].apply(lambda x: self.generate_adm("ADM6"))

        df["KI"] = df["KI"].apply(lambda x: self.data_generator.generate_ki())
        df["ACC"] = df["IMSI"].apply(lambda imsi: self.data_processor.generate_acc(imsi=str(imsi)))

        #        self.apply_function(df, "EKI", "KI", functions)
        self.apply_function(df, "EKI", "KI", self.generate_eki)
        self.apply_function(df, "OPC", "KI", self.generate_opc)

        for i in range(1, 4):
            for key in ["KIC", "KID", "KIK"]:
                col = f"{key}{i}"
                if col in df.columns:
                    df[col] = df["KI"].apply(
                        lambda x: self.data_generator.generate_otas()
                    )
#        df.to_csv("temp.csv")
        return df

    def generate_demo_data(self):
        df = self.df_processor.generate_empty_dataframe(default_headers, self.params.get_DATA_SIZE())
        self.df_processor.initialize_column(df, "ICCID", self.params.get_ICCID())
        self.df_processor.initialize_column(df, "IMSI", self.params.get_IMSI())
        self.df_processor.initialize_column(df, "OP", self.params.get_OP(), increment=False)
        self.df_processor.initialize_column(df, "K4", self.params.get_K4(), increment=False)
        return self.apply_functions(df)

    def generate_non_demo_data(self):
        input_df = self.dataframes.get_INPUT_DF()
        df = self.df_processor.generate_empty_dataframe(default_headers, len(input_df))
        self.df_processor.initialize_column(df, 'OP', self.params.get_OP(), increment=False)
        self.df_processor.initialize_column(df, 'K4', self.params.get_K4(), increment=False)
        df["ICCID"] = input_df["ICCID"]
        df["IMSI"] = input_df["IMSI"]
        return self.apply_functions(df)

    def generate_initial_data(self, is_demo: bool):
        if is_demo:
            return self.generate_demo_data(), {
                "k4": self.params.get_K4(),
                "op": self.params.get_OP(),
            }
        return self.generate_non_demo_data(), {
            "k4": self.params.get_K4(),
            "op": self.params.get_OP(),
        }

    def process_final_data(self, input_dict: dict, df_input: pd.DataFrame, clip: bool, encoding: bool):
#        print("In process_final_data()", clip, encoding)
        df = df_input.copy(deep=True)
        if encoding:
            df = self.df_processor.encode_dataframe(df)

        headers, _, _, _, left_ranges, right_ranges = (self.data_processor.extract_parameter_info(input_dict))
        df = self.df_processor.add_duplicate_columns(df, 10, headers)

        if clip:
            df = self.df_processor.clip_columns(df, left_ranges, right_ranges)
        print(df)
        return df

    def generate_all_data(self):
        # initial_df, keys_dict = self.generate_initial_data(
        #     self.params.get_PRODUCTION_CHECK()
        # )
        initial_df, keys_dict = self.generate_initial_data(True)
        # print(initial_df.head())
        data_types = {bool, dict, bool, bool}
        data_types = {
            "SERVER": (
                self.params.get_SERVER_CHECK(),
                self.params.get_SERVER_DICT(),
                False,
                False,
            ),
            "GRAPH": (
                self.params.get_GRAPH_CHECK(),
                self.params.get_GRAPH_DICT(),
                True,
                False,
            ),
            "ELECT": (
                self.params.get_ELECT_CHECK(),
                self.params.get_ELECT_DICT(),
                False,
                True,
            ),
        }
        result_dfs = {}
        for data_type, (check, dict_func, clip, encoding) in data_types.items():
            if check:
                result_dfs[data_type] = self.process_final_data(
                    dict_func, initial_df, clip, encoding
                )
        return result_dfs, keys_dict


