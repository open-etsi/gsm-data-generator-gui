"""
STC_APP_Scriptv6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nz_MGqPs5z1rz_G6NBl8xH-dQJxeK1Z3 : Private
    Author : Hamza Qureshi

DESCRIPTION
This code include following :
1. Create demo data dynamic method
2. Generate all parameters added by user from Application/settings.json[Working Fine]
3. Get input file
4. Create output CSV or Text files [data, laser and server files] as well
"""

# !pip install pycryptodome
# you can use requirements.txt
# from core.GlobalParams import PARAMETERS, DATA_FRAMES

from globals.parameters import PARAMETERS, DATA_FRAMES

# from GlobalParams import PARAMETERS, DATA_FRAMES
from generator.utils import (
    CryptoUtils,
    DataGenerator,
    DataProcessing,
    DataFrameProcessor,
)

# from json_utils import JsonHandler

# from custom_json import JsonHandler
from typing import Optional, List, Dict, Any, Tuple

# from pydantic import BaseModel, Field
from Crypto.Cipher import AES
from io import BytesIO
import secrets
import pandas as pd
import collections
import binascii
import datetime
import random
import string
import uuid
import json
import time
import os

# CONFIGURATION_FILE_PATH = "settings.json"

default_headers = (
    "ICCID",
    "IMSI",
    "OP",
    "K4",
    "PIN1",
    "PUK1",
    "PIN2",
    "PUK2",
    "KI",
    "EKI",
    "OPC",
    "ADM1",
    "ADM6",
    "ACC",
    "KIC1",
    "KID1",
    "KIK1",
    "KIC2",
    "KID2",
    "KIK2",
    "KIC3",
    "KID3",
    "KIK3",
)


def list_2_dict(list: list) -> dict:
    dict = {}
    for index in range(0, len(list)):
        dict[str(index)] = [list[index], "Normal", "0-31"]
    return dict


def dict_2_list(d: dict) -> list:
    list1 = []
    for index, j in enumerate(d):
        temp = list(d.values())[index][0]
        list1.append(temp)
    return list1


# # m_zong = ZongGenerateHandle()

# # m_zong.set_json_to_UI()
# # m_zong.Generate_laser_file("AAA",s.dataframes.GRAPH_DF)
# # m_zong.Generate_servr_file("ASD",s.dataframes.SERVR_DF)
# # m_zong.Generate_elect_file("ASD",s.dataframes.ELECT_DF)


def read_json(file_path: str):
    try:
        with open(file_path, "r") as json_file:
            data = json.load(json_file)
        return dict(data)
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
        return None  # You can choose to return None or raise a custom exception here
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON in '{file_path}': {e}")
        return None  # You can choose to return None or raise a custom exception here


def copy_function(x):
    return str(x)


class DataGenerationScript:

    def __init__(self, config_holder):
        self.params = PARAMETERS.get_instance()
        self.dataframes = DATA_FRAMES.get_instance()
        self.crypto_utils = CryptoUtils()
        self.data_generator = DataGenerator()
        self.data_processor = DataProcessing()
        self.df_processor = DataFrameProcessor()

    def SET_ALL_DISP_PARAMS(self):
        self.params.set_K4(config_holder.DISP.K4)
        self.params.set_OP(config_holder.DISP.op)
        self.params.set_IMSI(config_holder.DISP.iccid)
        self.params.set_ICCID(config_holder.DISP.imsi)
        self.params.set_PIN1(config_holder.DISP.pin1)
        self.params.set_PUK1(config_holder.DISP.puk1)
        self.params.set_PIN2(config_holder.DISP.pin2)
        self.params.set_PUK2(config_holder.DISP.puk2)
        self.params.set_ADM1(config_holder.DISP.adm1)
        self.params.set_ADM6(config_holder.DISP.adm6)
        self.params.set_ACC("0111")
        self.params.set_DATA_SIZE(config_holder.DISP.size)

        self.params.set_PRODUCTION_CHECK(False)
        self.params.set_ELECT_CHECK(config_holder.DISP.elect_check)
        self.params.set_GRAPH_CHECK(config_holder.DISP.graph_check)
        self.params.set_SERVER_CHECK(config_holder.DISP.server_check)

        self.params.set_SERVER_DICT(
            list_2_dict(config_holder.PARAMETERS.server_variables)
        )
        self.params.set_ELECT_DICT(list_2_dict(config_holder.PARAMETERS.data_variables))
        self.params.set_GRAPH_DICT((config_holder.PARAMETERS.laser_variables))
        #  params.set_INPUT_PATH("C:/Users/hamza.qureshi/Desktop/STC_APP/improvements/dataGen-v17/input.csv")
        self.params.set_INPUT_PATH(config_holder.PATHS.INPUT_FILE_PATH)

        # ========================================#
        # ========================================#
        # ========================================#

        self.params.set_PIN1_RAND(False)
        self.params.set_PUK1_RAND(True)
        self.params.set_PIN2_RAND(False)
        self.params.set_PUK2_RAND(False)
        self.params.set_ADM1_RAND(False)
        self.params.set_ADM6_RAND(True)
        self.params.set_ACC_RAND(False)

    def generate_eki(self, ki):
        return self.data_generator.generate_eki(self.params.get_K4(), ki)

    def generate_opc(self, ki):
        return self.data_generator.generate_opc(self.params.get_OP(), ki)

    def generate_pin(self, pin_type):
        if getattr(self.params, f"get_{pin_type}_RAND")():
            return getattr(self.params, f"get_{pin_type}")()
        return self.data_generator.generate_4_digit()

    def generate_puk(self, puk_type):
        if getattr(self.params, f"get_{puk_type}_RAND")():
            return getattr(self.params, f"get_{puk_type}")()
        return self.data_generator.generate_8_digit()

    def generate_adm(self, adm_type):
        if getattr(self.params, f"get_{adm_type}_RAND")():
            return getattr(self.params, f"get_{adm_type}")()
        return self.data_generator.generate_8_digit()

    #    @staticmethod
    def apply_function(self, df, dest: str, src: str, function):
        if dest in df.columns:
            df[dest] = df[src].apply(function).copy(deep=False)

    def apply_functions(self, df):
        df["ICCID"] = df["ICCID"].apply(lambda x: copy_function(x))
        df["IMSI"] = df["IMSI"].apply(lambda x: copy_function(x))
        df["PIN1"] = df["PIN1"].apply(lambda x: self.generate_pin("PIN1"))
        df["PIN2"] = df["PIN2"].apply(lambda x: self.generate_pin("PIN2"))
        df["PUK1"] = df["PUK1"].apply(lambda x: self.generate_pin("PUK1"))
        df["PUK2"] = df["PUK2"].apply(lambda x: self.generate_pin("PUK2"))

        df["ADM1"] = df["ADM1"].apply(lambda x: self.generate_adm("ADM1"))
        df["ADM6"] = df["ADM6"].apply(lambda x: self.generate_adm("ADM6"))

        df["KI"] = df["KI"].apply(lambda x: self.data_generator.generate_ki())
        df["ACC"] = df["IMSI"].apply(
            lambda imsi: self.data_processor.generate_acc(imsi=str(imsi))
        )

        #        self.apply_function(df, "EKI", "KI", functions)
        self.apply_function(df, "EKI", "KI", self.generate_eki)
        self.apply_function(df, "OPC", "KI", self.generate_opc)

        for i in range(1, 4):
            for key in ["KIC", "KID", "KIK"]:
                col = f"{key}{i}"
                if col in df.columns:
                    df[col] = df["KI"].apply(
                        lambda x: self.data_generator.generate_otas()
                    )
        df.to_csv("temp.csv")
        return df

    def generate_demo_data(self):
        df = self.df_processor.generate_empty_dataframe(
            default_headers, self.params.get_DATA_SIZE()
        )

        print("-------> ", self.params.get_K4())
        self.df_processor.initialize_column(df, "ICCID", self.params.get_ICCID())
        self.df_processor.initialize_column(df, "IMSI", self.params.get_IMSI())

        self.df_processor.initialize_column(
            df, "OP", self.params.get_OP(), increment=False
        )
        self.df_processor.initialize_column(
            df, "K4", self.params.get_K4(), increment=False
        )
        return self.apply_functions(df)

    def generate_non_demo_data(self):
        input_df = self.dataframes.get_INPUT_DF()
        df = self.df_processor.generate_empty_dataframe(default_headers, len(input_df))
        #        self.df_processor.initialize_column(df, 'OP', self.params.get_OP(), increment=False)
        #        self.df_processor.initialize_column(df, 'K4', self.params.get_K4(), increment=False)
        df["ICCID"] = input_df["ICCID"]
        df["IMSI"] = input_df["IMSI"]
        return self.apply_functions(df)

    def generate_initial_data(self, is_demo: bool):
        if is_demo:
            return self.generate_demo_data(), {
                "k4": self.params.get_K4(),
                "op": self.params.get_OP(),
            }
        return self.generate_non_demo_data(), {
            "k4": self.params.get_K4(),
            "op": self.params.get_OP(),
        }

    def process_final_data(
        self, input_dict: dict, df_input: pd.DataFrame, clip: bool, encoding: bool
    ):
        print("In process_final_data()", input_dict)
        df = df_input.copy(deep=True)
        if encoding:
            df = self.df_processor.encode_dataframe(df)

        headers, _, _, _, left_ranges, right_ranges = (
            self.data_processor.extract_parameter_info(input_dict)
        )
        df = self.df_processor.add_duplicate_columns(df, 10, headers)

        if clip:
            df = self.df_processor.clip_columns(df, left_ranges, right_ranges)

        return df

    def generate_all_data(self):
        # initial_df, keys_dict = self.generate_initial_data(
        #     self.params.get_PRODUCTION_CHECK()
        # )
        initial_df, keys_dict = self.generate_initial_data(True)
        #        print(initial_df.head())
        data_types = {bool, dict, bool, bool}
        data_types = {
            "SERVER": (
                self.params.get_SERVER_CHECK(),
                self.params.get_SERVER_DICT(),
                False,
                False,
            ),
            "GRAPH": (
                self.params.get_GRAPH_CHECK(),
                self.params.get_GRAPH_DICT(),
                True,
                False,
            ),
            "ELECT": (
                self.params.get_ELECT_CHECK(),
                self.params.get_ELECT_DICT(),
                False,
                True,
            ),
        }
        result_dfs = {}
        for data_type, (check, dict_func, clip, encoding) in data_types.items():
            if check:
                result_dfs[data_type] = self.process_final_data(
                    dict_func, initial_df, clip, encoding
                )
        return result_dfs, keys_dict

    # def set_all_parameters(self):
    #     # Set default parameters
    #     params = {
    #         "K4": "111150987DE41E9F0808193003B543296D0A01D797B511AFDAEEEAC53BC61111",
    #         "OP": "1111006F86FAD6540D86FEF24D261111",
    #         "IMSI": 999990000000400,
    #         "ICCID": 999900000000000400,
    #         "PIN1": "0000",
    #         "PUK1": "00000000",
    #         "PIN2": "5555",
    #         "PUK2": "4444",
    #         "ADM1": "11111111",
    #         "ADM6": "11111111",
    #         "ACC": "0111",
    #         "DATA_SIZE": 7,
    #         "PRODUCTION_CHECK": False,
    #         "ELECT_CHECK": True,
    #         "GRAPH_CHECK": True,
    #         "SERVER_CHECK": True,
    #         "INPUT_PATH": "templates/N2023031016844011.txt",
    #         "PIN1_RAND": True,
    #         "PUK1_RAND": True,
    #         "PIN2_RAND": True,
    #         "PUK2_RAND": True,
    #         "ADM1_RAND": True,
    #         "ADM6_RAND": True,
    #         "ACC_RAND": True,
    #     }

    #     for key, value in params.items():
    #         setter = getattr(self.params, f"set_{key}")
    #         setter(value)

    # def get_all_parameters(self) -> dict:
    #     return {
    #         param: getattr(self.params, f"get_{param}")()
    #         for param in [
    #             "PRODUCTION_CHECK",
    #             "OP",
    #             "K4",
    #             "ICCID",
    #             "IMSI",
    #             "PIN1",
    #             "PUK1",
    #             "PIN2",
    #             "PUK2",
    #             "ADM1",
    #             "ADM6",
    #             "ACC",
    #             "DATA_SIZE",
    #             "INPUT_PATH",
    #         ]
    #     }


# from parser.utils import ConfigData, json_loader
from parser.utils import ConfigHolder, json_loader

if __name__ == "__main__":
    config_holder: ConfigHolder = json_loader(
        "D:/STC_APP/improvements/security-layer/datageneration/core/settings.json"
    )

    s = DataGenerationScript(config_holder=config_holder)

    # j = JsonHandler()
    # factory_data_json_path = CONFIGURATION_FILE_PATH
    # j.read_paths()
    # j.read_variables()
    s.SET_ALL_DISP_PARAMS()  # testing
    # s.SET_HEADERS()

    # (
    #     s.dataframes.__ELECT_DF,
    #     s.dataframes.__GRAPH_DF,
    #     #    s.dataframes.__SERVR_DF,
    #     #    s.dataframes.__KEYS,
    # ) = s.generate_all_data()

    (dfs, keys) = s.generate_all_data()

    # print(s.generate_all_data())
    # print(dfs["ELECT"])
    # print(dfs["GRAPH"])
    # print(dfs["SERVER"])
# print(keys)
# print(s.dataframes.__SERVR_DF)
